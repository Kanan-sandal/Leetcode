BRUTE FORCE:
class Solution {
  public:
    int inversionCount(vector<int> &arr) {
        // Code Here
        int n=arr.size();
        int count=0;
        for(int i=0;i<n-1;i++){
            for(int j=i+1;j<n;j++){
                if(arr[i]>arr[j]){
                    count+=1;
                }
            }
        }
        return count;
    }
};



OPTIMAL:
class Solution {
  private:
    long long mergeandcount(vector<int> &arr,int left,int mid,int right){
        long long count=0;
        vector<int> temp;
        int i=left,j=mid+1;
        
        while(i<=mid && j<=right){
            if(arr[i]<=arr[j]){
                temp.push_back(arr[i]);
                i++;
            }else{
                temp.push_back(arr[j]);
                j++;
                count+=(mid-i+1);
            }
        }
        while(i<=mid) temp.push_back(arr[i++]);
        while(j<=right) temp.push_back(arr[j++]);
        
        for(int k=left;k<=right;k++){
            arr[k]=temp[k-left];
        }
        return count;
    }
    
    long long mergesortandcount(vector<int>& arr,int left,int right){
        long long count=0;
        if(left<right){
            int mid=left+(right-left)/2;
            count+=mergesortandcount(arr,left,mid);
            count+=mergesortandcount(arr,mid+1,right);
            count+=mergeandcount(arr,left,mid,right);
        }
        return count;
    }
  public:
    long long inversionCount(vector<int> &arr) {
        return mergesortandcount(arr,0,arr.size()-1);
    }
};
